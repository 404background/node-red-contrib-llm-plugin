<link rel="stylesheet" type="text/css" href="vibecoding_styles.css">

<script type="text/javascript">
    function initializeWhenReady() {
        if (typeof RED !== 'undefined' && RED.sidebar) {
            RED.sidebar.addTab({
                id: "vibecoding-tab",
                label: "VibeCoding", 
                name: "VibeCoding",
                content: createVibeCodingUI(),
                iconClass: "fa fa-comments",
                closeable: true,
                visible: true
            });
        } else {
            setTimeout(initializeWhenReady, 100);
        }
    }
    
    function createVibeCodingUI() {
        var container = jQuery('<div>').addClass('vibecoding-container');
        
        var header = jQuery('<div>').addClass('vibecoding-header');
        var title = jQuery('<h3>').addClass('vibecoding-title').text('VibeCoding Chat');
        header.append(title);
        
        var chatArea = jQuery('<div>').addClass('vibecoding-chat').attr('id', 'vibecoding-chat');
        
        var inputArea = jQuery('<div>').addClass('vibecoding-input');
        
        var flowContextOption = jQuery('<div>').addClass('flow-context-option');
        var flowContextCheckbox = jQuery('<input>').attr({
            type: 'checkbox',
            id: 'vibecoding-include-flow',
            checked: true
        });
        var flowContextLabel = jQuery('<label>').attr('for', 'vibecoding-include-flow').text(' Send current flow');
        flowContextOption.append(flowContextCheckbox, flowContextLabel);
        
        var modelInput = jQuery('<input>').attr({
            type: 'text',
            id: 'vibecoding-model',
            placeholder: 'Model (e.g., llama3.2:latest)'
        }).addClass('model-input');
        
        var modelSuggestions = jQuery('<div>').addClass('model-suggestions').attr('id', 'vibecoding-model-suggestions');
        
        var promptGroup = jQuery('<div>').addClass('prompt-input-group');
        var promptInput = jQuery('<textarea>').attr({
            id: 'vibecoding-prompt',
            placeholder: 'Ask something or request a flow...'
        }).addClass('prompt-input');
        var generateBtn = jQuery('<button>').attr('id', 'vibecoding-generate').addClass('generate-btn').text('Send');
        promptGroup.append(promptInput, generateBtn);
        
        inputArea.append(flowContextOption, modelInput, modelSuggestions, promptGroup);
        container.append(header, chatArea, inputArea);
        
        setTimeout(function() {
            initializeClientApp();
        }, 100);
        
        return container;
    }
    
    window.createVibeCodingUI = createVibeCodingUI;
    initializeWhenReady();

    function initializeClientApp() {
        var generateBtn = jQuery('#vibecoding-generate');
        var modelInput = jQuery('#vibecoding-model');
        var promptInput = jQuery('#vibecoding-prompt');
        var chatArea = jQuery('#vibecoding-chat');
        var flowContextCheckbox = jQuery('#vibecoding-include-flow');
        
        loadRecentModels();
        
        generateBtn.click(handleGenerate);
        promptInput.keypress(function(e) {
            if (e.which === 13 && e.ctrlKey) {
                handleGenerate();
            }
        });
        
        function loadRecentModels() {
            jQuery.get('vibecoding/recent-models')
                .done(function(data) {
                    if (data.models && data.models.length > 0) {
                        var modelSuggestions = jQuery('#vibecoding-model-suggestions');
                        modelSuggestions.empty();
                        data.models.forEach(function(model) {
                            var chip = jQuery('<span>').addClass('model-chip')
                                .text(model)
                                .click(function() { modelInput.val(model); });
                            modelSuggestions.append(chip);
                        });
                    }
                })
                .fail(function() {
                    console.log('Could not load recent models');
                });
        }
        
        function handleGenerate() {
            var model = modelInput.val().trim();
            var prompt = promptInput.val().trim();
            
            if (!model || !prompt) {
                if (RED && RED.notify) {
                    RED.notify('Please enter both model and prompt', 'warning');
                }
                return;
            }
            
            addMessage(prompt, true);
            promptInput.val('');
            
            var loadingMsg = addMessage('Generating...', false);
            generateBtn.prop('disabled', true);
            
            var currentFlow = flowContextCheckbox.is(':checked') ? getCurrentFlow() : null;
            
            jQuery.ajax({
                url: 'vibecoding/generate',
                method: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({
                    model: model,
                    prompt: prompt,
                    currentFlow: currentFlow
                }),
                timeout: 120000
            })
            .done(function(data) {
                loadingMsg.remove();
                addMessage(data.response, false);
            })
            .fail(function(xhr, status, error) {
                loadingMsg.remove();
                var errorMsg = 'Request failed';
                if (xhr.responseJSON && xhr.responseJSON.error) {
                    errorMsg = xhr.responseJSON.error;
                } else if (status === 'timeout') {
                    errorMsg = 'Request timed out';
                } else if (xhr.status === 404) {
                    errorMsg = 'VibeCoding endpoint not found. Check plugin installation.';
                } else {
                    errorMsg = error || 'Unknown error';
                }
                addMessage('Error: ' + errorMsg, false);
            })
            .always(function() {
                generateBtn.prop('disabled', false);
            });
        }
        
        function addMessage(content, isUser) {
            var message = jQuery('<div>').addClass('vibecoding-message')
                .addClass(isUser ? 'user-message' : 'assistant-message');
            
            var messageContent = jQuery('<div>').addClass('message-content')
                .html(formatMessage(content));
            
            message.append(messageContent);
            
            if (!isUser && content.indexOf('`json') !== -1) {
                var flowActions = jQuery('<div>').addClass('flow-actions');
                var importBtn = jQuery('<button>').text('Import Flow')
                    .click(function() { importFlowFromMessage(content); });
                flowActions.append(importBtn);
                messageContent.append(flowActions);
            }
            
            chatArea.append(message);
            chatArea.scrollTop(chatArea[0].scrollHeight);
            
            return message;
        }
        
        function formatMessage(text) {
            text = text.replace(/`json\n([\s\S]*?)\n`/g, '<pre class="json-block"><code></code></pre>');
            text = text.replace(/`([\s\S]*?)`/g, '<pre><code></code></pre>');
            text = text.replace(/\n/g, '<br>');
            return text;
        }
        
        function getCurrentFlow() {
            try {
                if (RED && RED.workspaces && RED.nodes) {
                    var activeWorkspace = RED.workspaces.active();
                    if (activeWorkspace) {
                        var nodes = RED.nodes.filterNodes({z: activeWorkspace});
                        var connections = [];
                        
                        // Get connections by examining node wires
                        nodes.forEach(function(node) {
                            if (node.wires && node.wires.length > 0) {
                                node.wires.forEach(function(wireArray, outputPort) {
                                    if (wireArray && wireArray.length > 0) {
                                        wireArray.forEach(function(targetNodeId) {
                                            var targetNode = RED.nodes.node(targetNodeId);
                                            if (targetNode) {
                                                connections.push({
                                                    from: {
                                                        id: node.id,
                                                        port: outputPort
                                                    },
                                                    to: {
                                                        id: targetNodeId,
                                                        port: 0 // Input port is typically 0
                                                    }
                                                });
                                            }
                                        });
                                    }
                                });
                            }
                        });
                        
                        return {
                            id: activeWorkspace,
                            label: RED.nodes.workspace(activeWorkspace).label || 'Flow',
                            nodes: nodes.map(function(node) {
                                var nodeInfo = {
                                    id: node.id,
                                    type: node.type,
                                    name: node.name || '',
                                    x: node.x,
                                    y: node.y
                                };
                                
                                // Add node-specific properties
                                if (node.type === 'function') {
                                    nodeInfo.func = node.func || '';
                                }
                                if (node.type === 'inject') {
                                    nodeInfo.payload = node.payload;
                                    nodeInfo.payloadType = node.payloadType;
                                }
                                if (node.type === 'debug') {
                                    nodeInfo.property = node.property || 'payload';
                                }
                                if (node.type === 'change') {
                                    nodeInfo.rules = node.rules || [];
                                }
                                if (node.type === 'http request') {
                                    nodeInfo.method = node.method;
                                    nodeInfo.url = node.url;
                                }
                                
                                return nodeInfo;
                            }),
                            connections: connections
                        };
                    }
                }
            } catch (error) {
                console.warn('Error getting current flow:', error);
            }
            return null;
        }
        
        function importFlowFromMessage(content) {
            try {
                var jsonMatch = content.match(/`json\s*\n([\s\S]*?)\n\s*`/);
                if (jsonMatch && RED && RED.view) {
                    var flowJSON = JSON.parse(jsonMatch[1]);
                    var nodes = flowJSON.nodes || flowJSON;
                    if (!Array.isArray(nodes)) nodes = [nodes];
                    
                    var activeWorkspace = RED.workspaces.active();
                    nodes.forEach(function(node) {
                        if (!node.z) node.z = activeWorkspace;
                    });
                    
                    RED.view.importNodes(nodes, { generateIds: true, addToHistory: true });
                    
                    if (RED.notify) RED.notify('Flow imported successfully', 'success');
                }
            } catch (error) {
                if (RED && RED.notify) RED.notify('Failed to import flow: ' + error.message, 'error');
            }
        }
    }
</script>
