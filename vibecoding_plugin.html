<link rel="stylesheet" type="text/css" href="vibecoding_styles.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" crossorigin="anonymous">

<script type="text/javascript">
(function() {
    // Chat management variables
    var currentChatId = null;
    var chatHistory = {};
    
    function generateChatId() {
        return 'chat_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
    
    function getCurrentChatId() {
        if (!currentChatId) {
            currentChatId = generateChatId();
            chatHistory[currentChatId] = {
                id: currentChatId,
                title: 'New Chat',
                messages: [],
                created: new Date().toISOString()
            };
        }
        return currentChatId;
    }
    
    function startNewChat() {
        currentChatId = generateChatId();
        chatHistory[currentChatId] = {
            id: currentChatId,
            title: 'New Chat',
            messages: [],
            created: new Date().toISOString()
        };
        
        // Clear chat area
        var chatArea = jQuery('#vibecoding-chat');
        chatArea.empty();
        
        if (RED && RED.notify) RED.notify('Started new chat', 'success');
    }
    
    function saveChatToServer(chatId) {
        var chat = chatHistory[chatId];
        if (chat && chat.messages.length > 0) {
            jQuery.ajax({
                url: 'vibecoding/save-chat',
                method: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({
                    chatId: chatId,
                    chatData: chat
                })
            }).fail(function(error) {
                console.error('Failed to save chat:', error);
            });
        }
    }
    
    function loadChatHistoriesFromServer() {
        return jQuery.get('vibecoding/chat-histories')
            .done(function(data) {
                if (data.chatHistories) {
                    chatHistory = data.chatHistories;
                }
            })
            .fail(function(error) {
                console.error('Failed to load chat histories:', error);
            });
    }
    
    function showChatList() {
        var chats = Object.values(chatHistory).sort((a, b) => new Date(b.created) - new Date(a.created));
        
        var modal = jQuery('<div>').addClass('chat-modal');
        var modalContent = jQuery('<div>').addClass('chat-modal-content');
        
        var modalHeader = jQuery('<div>').addClass('modal-header');
        var modalTitle = jQuery('<h3>').text('Chat History');
        var closeBtn = jQuery('<button>').addClass('close-btn').text('×')
            .attr('title', 'Close')
            .click(function() { modal.remove(); });
        modalHeader.append(modalTitle, closeBtn);
        
        var chatList = jQuery('<div>').addClass('chat-list');
        
        if (chats.length === 0) {
            chatList.append(jQuery('<p>').text('No chat history found.'));
        } else {
            chats.forEach(function(chat) {
                var chatItem = jQuery('<div>').addClass('chat-item');
                if (chat.id === currentChatId) chatItem.addClass('current-chat');
                
                var chatInfo = jQuery('<div>').addClass('chat-info');
                var chatTitle = jQuery('<div>').addClass('chat-title').text(chat.title);
                var chatDate = jQuery('<div>').addClass('chat-date').text(new Date(chat.created).toLocaleString());
                var messageCount = jQuery('<div>').addClass('message-count').text(chat.messages.length + ' messages');
                chatInfo.append(chatTitle, chatDate, messageCount);
                
                var chatActions = jQuery('<div>').addClass('chat-actions');
                var loadBtn = jQuery('<button>').addClass('load-btn').text('Load')
                    .click(function() { loadChat(chat.id); modal.remove(); });
                var deleteBtn = jQuery('<button>').addClass('delete-btn').text('Delete')
                    .click(function() { deleteChat(chat.id); showChatList(); });
                chatActions.append(loadBtn, deleteBtn);
                
                chatItem.append(chatInfo, chatActions);
                chatList.append(chatItem);
            });
        }
        
        modalContent.append(modalHeader, chatList);
        modal.append(modalContent);
        jQuery('body').append(modal);
    }
    
    function loadChat(chatId) {
        if (chatHistory[chatId]) {
            currentChatId = chatId;
            var chat = chatHistory[chatId];
            var chatArea = jQuery('#vibecoding-chat');
            chatArea.empty();
            
            chat.messages.forEach(function(msg) {
                addMessageToUI(msg.content, msg.isUser, false);
            });
            
            if (RED && RED.notify) RED.notify('Loaded chat: ' + chat.title, 'success');
        }
    }
    
    function deleteChat(chatId) {
        if (confirm('Delete this chat? This cannot be undone.')) {
            // サーバーにも削除リクエスト
            jQuery.ajax({
                url: 'vibecoding/delete-chat',
                method: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({ chatId: chatId })
            }).always(function() {
                delete chatHistory[chatId];
                if (currentChatId === chatId) {
                    startNewChat();
                }
            });
        }
    }
    
    function addMessage(content, isUser) {
        // Save to chat history
        var chatId = getCurrentChatId();
        var chat = chatHistory[chatId];
        
        chat.messages.push({
            content: content,
            isUser: isUser,
            timestamp: new Date().toISOString()
        });
        
        // Update chat title based on first user message
        if (isUser && chat.messages.filter(m => m.isUser).length === 1) {
            chat.title = content.substring(0, 50) + (content.length > 50 ? '...' : '');
        }
        
        // Save to server after each message
        saveChatToServer(chatId);
        
        return addMessageToUI(content, isUser, true);
    }
    
    function addMessageToUI(content, isUser, showActions) {
        var chatArea = jQuery('#vibecoding-chat');
        
        var message = jQuery('<div>').addClass('vibecoding-message')
            .addClass(isUser ? 'user-message' : 'assistant-message');
        
        var messageContent = jQuery('<div>').addClass('message-content')
            .html(formatMessage(content));
        
        message.append(messageContent);
        
        // Add message actions for assistant messages
        if (!isUser && showActions) {
            var messageActions = jQuery('<div>').addClass('message-actions');
            var retryBtn = jQuery('<button>').addClass('retry-btn')
                .html('<i class="fa fa-redo" aria-hidden="true" style="color:#222;"></i>')
                .attr('title', 'Retry message')
                .click(function() { retryLastMessage(); });
            messageActions.append(retryBtn);
            message.append(messageActions);
        }
        
        // Only add import button if there s actual JSON content with nodes
        if (!isUser && content.indexOf('```json') !== -1) {
            try {
                var jsonMatch = content.match(/```json\s*\n([\s\S]*?)\n\s*```/);
                if (jsonMatch) {
                    var testJSON = JSON.parse(jsonMatch[1]);
                    // Only show button if its a valid flow with nodes
                    if (testJSON && (Array.isArray(testJSON) || testJSON.nodes)) {
                        var flowActions = jQuery('<div>').addClass('flow-actions');
                        var importBtn = jQuery('<button>').addClass('import-btn').text('Import Flow')
                            .click(function() { importFlowFromMessage(content); });
                        flowActions.append(importBtn);
                        message.append(flowActions);
                    }
                }
            } catch (e) {
                // Invalid JSON, dont show button
            }
        }
        
        chatArea.append(message);
        chatArea.scrollTop(chatArea[0].scrollHeight);
        
        return message;
    }
    
    function formatMessage(text) {
        // Hide JSON blocks but keep them for import functionality
        text = text.replace(/```json\s*\n([\s\S]*?)\n\s*```/g, function(match, jsonContent) {
            try {
                var parsed = JSON.parse(jsonContent);
                if (parsed && (Array.isArray(parsed) || parsed.nodes)) {
                    return '<div class="json-hidden" data-json="' + encodeURIComponent(jsonContent) + '">Flow JSON (hidden - use Import Flow button)</div>';
                }
            } catch (e) {
                // Invalid JSON, hide it completely
            }
            return '';
        });

        // Format code blocks (```lang ... ```)
        text = text.replace(/```(\w+)?\s*\n([\s\S]*?)\n\s*```/g, '<pre><code class="language-$1">$2</code></pre>');

        // Headings (###, ##, #)
        text = text.replace(/^### (.*)$/gm, '<h3>$1</h3>');
        text = text.replace(/^## (.*)$/gm, '<h2>$1</h2>');
        text = text.replace(/^# (.*)$/gm, '<h1>$1</h1>');

        // Horizontal rule
        text = text.replace(/^---$/gm, '<hr>');

        // Unordered lists
        text = text.replace(/^(\s*)[-*] (.*)$/gm, '$1<li>$2</li>');
        text = text.replace(/(<li>.*<\/li>)/g, function(match) {
            // If not already inside <ul>, wrap in <ul>
            if (!/^<ul>/.test(match)) return '<ul>' + match + '</ul>';
            return match;
        });

        // Ordered lists
        text = text.replace(/^(\s*)\d+\. (.*)$/gm, '$1<li>$2</li>');
        text = text.replace(/(<li>.*<\/li>)/g, function(match) {
            // If not already inside <ol>, wrap in <ol>
            if (!/^<ol>/.test(match) && !/^<ul>/.test(match)) return '<ol>' + match + '</ol>';
            return match;
        });

        // Inline code
        text = text.replace(/`([^`]+)`/g, '<code>$1</code>');

        // Bold
        text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

        // Italic
        text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');

        // Line breaks
        text = text.replace(/\n/g, '<br>');

        return text;
    }
    
    function retryLastMessage() {
        var chatId = getCurrentChatId();
        var chat = chatHistory[chatId];
        
        if (chat.messages.length >= 2) {
            // Get the last user message
            var lastUserMessage = null;
            for (var i = chat.messages.length - 1; i >= 0; i--) {
                if (chat.messages[i].isUser) {
                    lastUserMessage = chat.messages[i];
                    break;
                }
            }
            
            if (lastUserMessage) {
                // Remove the last assistant message from history
                chat.messages = chat.messages.filter((msg, index) => {
                    return !(index === chat.messages.length - 1 && !msg.isUser);
                });
                
                // Remove last message from UI
                var chatArea = jQuery('#vibecoding-chat');
                chatArea.find('.assistant-message').last().remove();
                
                // Save updated history
                saveChatToServer(chatId);
                
                // Retry the generation
                retryGeneration(lastUserMessage.content);
            }
        }
    }
    
    function retryGeneration(prompt) {
        var modelInput = jQuery('#vibecoding-model');
        var flowContextCheckbox = jQuery('#vibecoding-include-flow');
        var generateBtn = jQuery('#vibecoding-generate');
        
        var model = modelInput.val().trim();
        if (!model) {
            if (RED && RED.notify) {
                RED.notify('Please enter a model name', 'warning');
            }
            return;
        }
        
        var loadingMsg = addMessageToUI('Generating...', false, false);
        loadingMsg.addClass('loading-message');
        generateBtn.prop('disabled', true);
        
        var currentFlow = flowContextCheckbox.is(':checked') ? getCurrentFlow() : null;
        
        jQuery.ajax({
            url: 'vibecoding/generate',
            method: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({
                model: model,
                prompt: prompt,
                currentFlow: currentFlow
            })
        })
        .done(function(data) {
            loadingMsg.remove();
            addMessage(data.response, false);
        })
        .fail(function(xhr, status, error) {
            loadingMsg.remove();
            var errorMsg = 'Request failed';
            if (xhr.responseJSON && xhr.responseJSON.error) {
                errorMsg = xhr.responseJSON.error;
            } else if (status === 'timeout') {
                errorMsg = 'Request timed out';
            } else if (xhr.status === 404) {
                errorMsg = 'VibeCoding endpoint not found. Check plugin installation.';
            } else {
                errorMsg = error || 'Unknown error';
            }
            addMessage('Error: ' + errorMsg, false);
        })
        .always(function() {
            generateBtn.prop('disabled', false);
        });
    }
    
    function importFlowFromMessage(messageContent) {
        try {
            var jsonMatch = messageContent.match(/```json\s*\n([\s\S]*?)\n\s*```/);
            if (!jsonMatch) {
                if (RED && RED.notify) RED.notify('No JSON flow found in message', 'warning');
                return;
            }
            
            var flowData = JSON.parse(jsonMatch[1]);
            
            if (RED && RED.view && flowData) {
                if (Array.isArray(flowData)) {
                    RED.view.importNodes(JSON.stringify(flowData));
                } else if (flowData.nodes) {
                    RED.view.importNodes(JSON.stringify(flowData.nodes));
                } else {
                    RED.view.importNodes(JSON.stringify([flowData]));
                }
                
                if (RED.notify) RED.notify('Flow imported successfully', 'success');
            }
        } catch (error) {
            console.error('Import error:', error);
            if (RED && RED.notify) RED.notify('Failed to import flow: ' + error.message, 'error');
        }
    }
    
    function getCurrentFlow() {
        try {
            if (RED && RED.workspaces && RED.nodes) {
                var activeWorkspace = RED.workspaces.active();
                if (activeWorkspace) {
                    // Get all nodes belonging to the current workspace/tab (z == activeWorkspace)
                    var nodes = RED.nodes.filterNodes({z: activeWorkspace});
                    // Also include the workspace/tab itself (type: 'tab')
                    var workspace = RED.nodes.workspace(activeWorkspace);
                    var exportArray = [];
                    if (workspace) {
                        exportArray.push(workspace);
                    }
                    // Add all nodes for this workspace
                    nodes.forEach(function(node) {
                        // Shallow copy to avoid circular references
                        var nodeCopy = Object.assign({}, node);
                        // Remove runtime-only properties if present
                        delete nodeCopy._def;
                        delete nodeCopy.__proto__;
                        exportArray.push(nodeCopy);
                    });
                    return exportArray;
                }
            }
        } catch (error) {
            console.error('Error getting current flow:', error);
        }
        return null;
    }
    
    function initializeWhenReady() {
        if (typeof RED !== 'undefined' && RED.sidebar) {
            RED.sidebar.addTab({
                id: "vibecoding-tab",
                label: "VibeCoding", 
                name: "VibeCoding",
                content: createVibeCodingUI(),
                iconClass: "fa fa-comments",
                closeable: true,
                visible: true
            });
        } else {
            setTimeout(initializeWhenReady, 100);
        }
    }
    
    function createVibeCodingUI() {
        var container = jQuery('<div>').addClass('vibecoding-container');
        
        var header = jQuery('<div>').addClass('vibecoding-header');
        var title = jQuery('<h3>').addClass('vibecoding-title').text('VibeCoding Chat');
        
        var headerButtons = jQuery('<div>').addClass('header-buttons');
        var newChatBtn = jQuery('<button>').addClass('header-btn').text('New Chat')
            .click(function() { startNewChat(); });
        var chatListBtn = jQuery('<button>').addClass('header-btn').text('Chats')
            .click(function() { showChatList(); });
        headerButtons.append(newChatBtn, chatListBtn);
        
        header.append(title, headerButtons);
        
        var chatArea = jQuery('<div>').addClass('vibecoding-chat').attr('id', 'vibecoding-chat');
        
        var inputArea = jQuery('<div>').addClass('vibecoding-input');
        
        var flowContextOption = jQuery('<div>').addClass('flow-context-option');
        var flowContextCheckbox = jQuery('<input>').attr({
            type: 'checkbox',
            id: 'vibecoding-include-flow',
            checked: true
        });
        var flowContextLabel = jQuery('<label>').attr('for', 'vibecoding-include-flow').text(' Send current flow');
        flowContextOption.append(flowContextCheckbox, flowContextLabel);
        
        var modelInput = jQuery('<input>').attr({
            type: 'text',
            id: 'vibecoding-model',
            placeholder: 'Model (e.g., llama3.2:latest)'
        }).addClass('model-input');
        
        var modelSuggestions = jQuery('<div>').addClass('model-suggestions').attr('id', 'vibecoding-model-suggestions');
        
        var promptGroup = jQuery('<div>').addClass('prompt-input-group');
        var promptInput = jQuery('<textarea>').attr({
            id: 'vibecoding-prompt',
            placeholder: 'Ask something or request a flow...'
        }).addClass('prompt-input');
        var generateBtn = jQuery('<button>').attr('id', 'vibecoding-generate').addClass('generate-btn').text('Send');
        promptGroup.append(promptInput, generateBtn);
        
        inputArea.append(flowContextOption, modelInput, modelSuggestions, promptGroup);
        container.append(header, chatArea, inputArea);
        
        setTimeout(function() {
            initializeClientApp();
        }, 100);
        
        return container;
    }
    
    function initializeClientApp() {
    var generateBtn = jQuery('#vibecoding-generate');
    var modelInput = jQuery('#vibecoding-model');
    var promptInput = jQuery('#vibecoding-prompt');
    var chatArea = jQuery('#vibecoding-chat');
    var flowContextCheckbox = jQuery('#vibecoding-include-flow');
    var currentRequest = null;
        
        // Load chat histories from server on startup
        loadChatHistoriesFromServer().then(function() {
            console.log('Chat histories loaded from server');
        });
        
        loadRecentModels();
        
        function bindGenerateBtn() {
            generateBtn.off('click').on('click', function() {
                if (generateBtn.hasClass('stop-btn')) {
                    // 停止ボタン時はabortのみ
                    if (currentRequest) {
                        currentRequest.abort();
                        jQuery('.loading-message').remove();
                        generateBtn.prop('disabled', false).removeClass('stop-btn').html('Send');
                        currentRequest = null;
                    }
                } else {
                    handleGenerate();
                }
            });
        }
        bindGenerateBtn();
        promptInput.keypress(function(e) {
            if (e.which === 13 && e.ctrlKey) {
                handleGenerate();
            }
        });
        
        function loadRecentModels() {
            jQuery.get('vibecoding/recent-models')
                .done(function(data) {
                    if (data.models && data.models.length > 0) {
                        var modelSuggestions = jQuery('#vibecoding-model-suggestions');
                        modelSuggestions.empty();
                        data.models.forEach(function(model) {
                            var chip = jQuery('<span>').addClass('model-chip')
                                .text(model)
                                .click(function() { modelInput.val(model); });
                            modelSuggestions.append(chip);
                        });
                    }
                })
                .fail(function() {
                    console.log('Could not load recent models');
                });
        }
        
        function handleGenerate() {
            var model = modelInput.val().trim();
            var prompt = promptInput.val().trim();
            if (!model || !prompt) {
                if (RED && RED.notify) {
                    RED.notify('Please enter both model and prompt', 'warning');
                }
                return;
            }
            addMessage(prompt, true);
            promptInput.val('');
            var loadingMsg = addMessageToUI('Generating...', false, false);
            loadingMsg.addClass('loading-message');
            generateBtn.prop('disabled', false).addClass('stop-btn').html('<i class="fa fa-stop" aria-hidden="true"></i>');
            bindGenerateBtn(); // 再バインド
            var currentFlow = flowContextCheckbox.is(':checked') ? getCurrentFlow() : null;
            if (currentRequest) { currentRequest.abort(); }
            currentRequest = jQuery.ajax({
                url: 'vibecoding/generate',
                method: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({
                    model: model,
                    prompt: prompt,
                    currentFlow: currentFlow
                })
            })
            .done(function(data) {
                loadingMsg.remove();
                addMessage(data.response, false);
            })
            .fail(function(xhr, status, error) {
                loadingMsg.remove();
                var errorMsg = 'Request failed';
                if (xhr.responseJSON && xhr.responseJSON.error) {
                    errorMsg = xhr.responseJSON.error;
                } else if (status === 'timeout') {
                    errorMsg = 'Request timed out';
                } else if (xhr.status === 404) {
                    errorMsg = 'VibeCoding endpoint not found. Check plugin installation.';
                } else if (status !== 'abort') {
                    errorMsg = error || 'Unknown error';
                }
                if (status !== 'abort') addMessage('Error: ' + errorMsg, false);
            })
            .always(function() {
                generateBtn.prop('disabled', false).removeClass('stop-btn').html('Send');
                bindGenerateBtn();
                currentRequest = null;
            });
        }
    }
    
    // Initialize the plugin
    initializeWhenReady();
})();
</script>
